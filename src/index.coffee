fs        = require 'fs'
path      = require 'path'
uglify    = require 'uglify-js'
resolve   = require './resolve'
compilers = require './compilers'
{log, print} = require './utils'

class Module
  @moduleCache = {}

  constructor: (requiredAs, options = {}) ->
    # relative or unqualified require to module
    @requiredAs = requiredAs

    # absolute path to module requiring us
    @requiredBy     = options.requiredBy

    # paths may be passed in if resolved in advance
    @absolutePath   = options.absolutePath
    @basePath       = options.basePath
    @extension      = options.extension
    @normalizedPath = options.normalizedPath
    @requireAs      = options.requireAs

    # compiler/extension options
    @compilers    = options.compilers ? compilers
    @extensions   = ('.' + ext for ext of compilers)

    # async, whether or not to include in bundled modules
    @async        = options.async ? false
    @exclude      = options.exclude

    # ast / source generated by @parse()
    @ast          = null
    @source       = null

    # modules that this module depends on
    @dependencies =
      async:        {}
      excluded:     {}
      required:     {}

    # modules that depend on this one
    @dependents = []
    if @requiredBy?
      @dependents.push @requiredBy

    # resolve rest of paths if necessary
    unless options.absolutePath? and options.requireAs?
      @[k] = v for k, v of resolve @requiredAs,
        requiredBy: @requiredBy
        basePath:   @basePath

    # cache ourself
    Module.moduleCache[@requireAs] = @

  # source wrapped in define statement.
  wrapped: ->
    """
    // source: #{@absolutePath}
    require.#{if @async then 'async' else 'define'}("#{@requireAs}", function(module, exports, __dirname, __filename) {
      #{@source}
    });
    """

  # compile source using appropriately compiler
  compile: (callback) ->
    fs.readFile @absolutePath, 'utf8', (err, source) =>
      unless (compiler = @compilers[@extension.substr 1])? and typeof compiler is 'function'
        throw new Error "No suitable compiler found for #{@absolutePath}"

      # call compiler with a reference to this module
      compiler.call @, {source: source, filename: @normalizedPath}, (err, source, sourceMap) =>
        throw err if err

        @source = source
        @sourceMap = sourceMap

        callback()

  # parse source file into ast
  parse: (callback) ->
    unless @source?
      @compile =>
        @parse callback
      return

    @ast = uglify.parse @wrapped(),
      filename: @normalizedPath

    nodes = []
    @ast.walk new uglify.TreeWalker (node, descend) ->
      # detect valid require statement for transform
      if (node instanceof uglify.AST_Call) \
          # node must start with require
          and node.start.value == 'require' \
          # node may not end with define, i.e., require.define
          and (not node.expression?.end?.value != 'define') \
          and node.args[0].value?
        nodes.push node
      return

    required = @resolveDependencies nodes

    # fully parse all required dependencies
    @parseDependencies required.slice 0, callback

  resolveDependencies: (nodes) ->
    while node = nodes.shift()
      required = node.args[0]
      extraArg = node.args[1]

      unless extraArg?
        async = false
      else if extraArg.start.value = 'function'
        async = true

      if required.value == @requireAs
        continue

      paths = resolve required.value,
        basePath:   @basePath
        extensions: @extensions
        requiredAs: required.value
        requiredBy: @absolutePath

      # normalize require path in AST
      required.value = paths.requireAs

      if @exclude? and @exclude.test paths.requireAs
        @dependencies.excluded[paths.requireAs] = paths
        continue

      if (cached = Module.moduleCache[paths.requireAs])?
        @dependencies.required[paths.requireAs] = cached
        continue

      module = new Module paths.requiredAs, paths
      module.async = async
      module.exclude = @exclude

      if module.async
        # async dependency
        @dependencies.async[module.requireAs] = module
      else
        @dependencies.required[module.requireAs] = module

    @dependencies.required

  parseDependencies: (unresolved, callback) ->
    if unresolved.length == 0
      return callback null

    module = unresolved.shift()
    module.parse (err) =>
      throw err if err

      @parseDependencies unresolved, callback

  toString: (options) ->
    print @ast, options

class Wrapper
  constructor: (options = {}) ->
    @prelude  = options.prelude ? (path.join __dirname, 'prelude.js')
    @bare     = options.bare    ? false
    @ast      = uglify.parse ''
    @lastNode = @ast

    unless @bare
      @ast = uglify.parse '(function (global){}.call(this))',
        toplevel: @ast

      @ast.walk new uglify.TreeWalker (node, descend) =>
        if node instanceof uglify.AST_Function
          @lastNode = node

    if typeof @prelude == 'string' and @prelude != ''
      prelude = uglify.parse (fs.readFileSync @prelude, 'utf8'),
        filename: 'requisite/prelude.js'

      @append prelude

  # can be passed an ast or module instance
  append: (ast) ->
    if ast instanceof Module
      ast = ast.ast

    @lastNode.body = @lastNode.body.concat ast.body
    @lastNode.end  = ast.end

  toString: (options) ->
    print @ast, options

module.exports =
  Module:  Module

  Wrapper: Wrapper

  bundle: (entry, options, callback) ->
    @walk entry, options, (err, wrapper) ->
      throw err if err
      callback null, (wrapper.toString options)

  walk: (entry, options, callback) ->
    if typeof options == 'function'
      [callback, options] = [options, {}]

    wrapper = new Wrapper
      prelude: options.prelude
      bare:    options.bare

    main = new Module entry,
      exclude: options.exclude

    main.parse ->
      wrapper.append main

      if options.include?
        unresolved = options.include.slice 0

        iterate = ->
          if unresolved.length = 0
            callback null, wrapper
          else
            module = new Module unresolved.shift(),
              requiredBy: main.absolutePath
              requiredBy: main.basePath
            module.parse ->
              wrapper.append module
              iterate()
        iterate()
