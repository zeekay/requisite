acorn = require 'esprima'
fs    = require 'fs'
path  = require 'path'

compilers       = require './compilers'
resolve         = require './resolve'
{codegen, walk} = require './utils'

class Module
  @moduleCache = {}

  constructor: (requiredAs, options = {}) ->
    # relative or unqualified require to module
    @requiredAs = requiredAs

    # absolute path to module requiring us
    @requiredBy     = options.requiredBy

    # compiler/extension options
    @compilers    = options.compilers ? compilers
    @extensions   = ('.' + ext for ext of compilers)

    # async, whether or not to include in bundled modules
    @async        = options.async ? false
    @exclude      = options.exclude

    # ast / source generated by @parse()
    @ast          = null
    @source       = null

    # modules that this module depends on
    @dependencies = {}

    # modules that depend on this one
    @dependents = {}

    # Optionally passed in if resolved in advance
    @absolutePath   = options.absolutePath
    @basePath       = options.basePath
    @normalizedPath = options.normalizedPath
    @requireAs      = options.requireAs

    # cache ourself
    Module.moduleCache[@requireAs] = @

  # resolve paths
  resolve: ->
    @[k] = v for k, v of resolve @requiredAs,
      requiredBy: @requiredBy
      basePath:   @basePath

  # source wrapped in define statement.
  wrap: (ast) ->
    wrapper = uglify.parse """
      // source: #{@absolutePath}
      require.#{if @async then 'async' else 'define'}("#{@requireAs}", function(module, exports, __dirname, __filename) {
        // replaced with source
      });
      """
    wrapper.body[0].body.args[1].body = [ast]
    wrapper

  # compile source using appropriately compiler
  compile: (callback) ->
    unless @absolutePath? and @normalizedPath?
      @resolve()

    extension = (@extension ? path.extname @absolutePath).substr 1
    fs.readFile @absolutePath, 'utf8', (err, source) =>
      unless (compiler = @compilers[extension])? and typeof compiler is 'function'
        throw new Error "No suitable compiler found for #{@absolutePath}"

      # call compiler with a reference to this module
      compiler.call @, {source: source, filename: @normalizedPath}, (err, source, sourceMap) =>
        throw err if err

        @source = source
        @sourceMap = sourceMap

        callback()

  # parse source file into ast
  parse: (callback) ->
    unless @source?
      @compile =>
        @parse callback
      return

    # parse source to AST
    @ast = acorn.parse @source,
      locations: true
      sourceFile: @normalizedPath

    # transform AST to use root-relative paths
    dependencies = @transform()

    # parse dependencies into fully-fledged modules
    @traverse dependencies, callback

  # transform require expressions in AST to use root-relative paths
  transform: ->
    dependencies = []
    walk @ast, (node) =>
      if node.type == 'CallExpression' and node.callee.name == 'require'
        [required, callback] = node.arguments

        if required.type == 'Literal'
          module = resolve required.value,
            basePath:   @basePath
            extensions: @extensions
            requiredAs: required.value
            requiredBy: @absolutePath

          # transform node
          required.value = module.requireAs

          # is async?
          module.async = callback?

          # add to list of dependencies
          dependencies.push module
        return true
    dependencies

  # traverse dependencies recursively, parsing them as well
  traverse: (dependencies, callback) ->
    unless dependencies.length == 0
      module = dependencies.shift()

      if (cached = Module.moduleCache[module.requireAs])?
        @dependencies[module.requireAs] = cached
        cached.dependents[@requireAs] = @
        return @traverse dependencies, callback

      module = new Module module.requiredAs, module
      module.exclude = @exclude
      module.dependents[@requireAs] = @

      if @exclude? and @exclude.test module.requireAs
        module.excluded = true
        return @traverse dependencies, callback
      else
        @dependencies[module.requireAs] = module

      # continue
      module.parse =>
        @traverse dependencies, callback
    else
      callback()

  toString: (options) ->
    codegen @ast, options

module.exports = Module
